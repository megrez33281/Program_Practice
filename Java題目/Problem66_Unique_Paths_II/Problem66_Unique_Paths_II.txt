//解法：以DP方式解題，將到每一格的方法數儲存，由於只能往右或往下，計算方法數只需將加上上方和左方的格子數
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int wid = obstacleGrid[0].length;
        int len = obstacleGrid.length;
        int[][] ans = new int[len][wid];
        if(obstacleGrid[0][0] == 1){return 0;}
        ans[0][0] = 1;
        for(int i=0; i<len; i++){
            for(int j=0; j<wid; j++){
                //若該格為1，不存在達到該路徑的方法
                if(obstacleGrid[i][j] != 1){
                    if(j -1 >=0){ans[i][j] += ans[i][j-1];}//加上左邊格子的方法數(若該點為障礙物，方法數為0)
                    if(i -1 >=0){ans[i][j] += ans[i-1][j];}//加上上邊格子的方法數(若該點為障礙物，方法數為0)
                }
            }

        }
        return ans[len-1][wid-1];
    }

}